## http
+ 概念：超文本传输协议，构建于TCP/IP协议之上，默认端口号为80，处于网络体系结构的应用层之上。http采用的是请求/响应的工作方式，是无连接无状态的。最新版本是http2，目前应用最广的版本是http1.1。
+ 特点：
    + 简单快速：每个资源的URI是固定的，想访问某个资源，只需要输入这个资源对应的URI即可。（URL（Uniform Resource Location）：统一资源定位符，URI（Uniform Resource Identifier）：统一资源标识符。URL是URI的子集）。
    + 灵活：每个HTTP头部有个Content-Type，一个HTTP协议通过设置不同的Content-Type值，可以完成不同类型的资源传输。
    + 无连接：即请求时建立连接，请求完释放连接，节省对系统资源的占用。可通过设置keep-alive来延长有效时间。
    + 无状态：指的是每个请求都是独立的，无法保留用户状态等信息，需通过cookie和session来实现。

## https
+ HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密。

## http1.1
1. 缓存处理：引入ETag、If-None-Match等新的缓存策略
2. 带宽优化
3. 异常码完善，新增了24个错误状态响应码
4. Host头处理
5. 长连接

## http2.0
1. header压缩
2. 采用二进制格式而非文本格式，解析起来更高效，更不容易出错
3. 多路复用，而非有序并阻塞的，只需一个连接即可实现并行（1.1中数据较大或速度较慢的响应会阻碍排在它后面的请求）
4. 服务端推送：主动推送内容到客户端的缓存中

## http缓存
+ 浏览器在请求某一资源时，会先获取该资源缓存的header信息，判断是否命中强缓存（cache-control和expires信息）
    + 若命中，直接从缓存中获取该资源信息，包括缓存header信息，本次请求不会与服务器进行通信。
    + 如果没有命中强缓存，浏览器会发送请求到服务器，请求会携带第一次返回的有关缓存的header字段信息（last-modified/If-Modified-Since和Etag/If-None-Match），由服务器根据header信息来比对结果是否协商缓存命中。若命中，则服务器返回新的相应header信息更新缓存中的对应header信息，但是不会返回资源内容，它会告知浏览器可以直接从缓存中获取；否则返回最新的资源内容。
+ 强缓存和协商缓存的区别：
    + **强缓存**：从缓存中取，200（from cache），不请求服务器
    + **协商缓存**：从缓存中取，304（not modified），请求服务器，通过服务器告知浏览器缓存是否可用
+ 为什么既有Last-Modified还有Etag
    + HTTP 1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题
        1. 一些文件也许会周期性的更改，但是它的内容并不改变（仅仅改变修改时间），这个时候并不希望客户端认为这个文件被修改了，而重新GET
        2. 某些文件修改非常频繁，比如在秒以下的时间内进行修改（1s修改N次），If-Modified-Since能检查到的粒度是s级的，这种修改无法判断
        3. 某些服务器不能精确的得到文件的最后修改时间
    + 利用Etag能够更加精确的控制缓存，因为Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符
    + Last-Modified与Etag一起使用，服务器会优先验证Etag，一致的情况下，才会继续比对Last-Modified，最后才决定返回304

## 常见状态码
+ [1xx]：表示请求已被接受，需要继续处理
+ [2xx]：表示成功状态
+ [3xx]：重定向状态
+ [4xx]：客户端错误
+ [5xx]：服务器端错误

## DNS解析：
+ 浏览器缓存 -> 本地host文件 -> 本地DNS解析器 -> 本地DNS服务器 -> 其他域名服务器请求

## 三次握手
1. 第一次：建立连接时，客户端发送syn包（seq=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号。
2. 第二次：服务器收到syn包，必须确认客户端的SYN（ack=j+1），同时自己也发送一个SYN包（seq=k），即SYN+ACK包，此时服务器进入SYN_RECV状态
3. 第三次：客户端收到服务器的SYN_ACK包，向服务器发送确认包ACK（ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

## 四次挥手
1. 客户端发送断开TCP连接请求的报文，其中报文中包含seq序列号，是由发送端随机生成的，并且还将报文中的FIN字段置为1，表示需要断开TCP连接。（FIN=1，seq=x，x由客户端随机生成）
2. 服务端会回复客户端发送的TCP断开请求报文，其包含seq序列号，是由回复端随机生成的，而且会产生ACK字段，ACK字段数值是在客户端发过来的seq序列号基础上加1进行回复，以便客户端收到信息时，知晓自己的TCP断开请求已经得到验证。（FIN=1，ACK=x+1，seq=y，y由服务端随机生成）
3. 服务端在回复完客户端的TCP断开请求后，不会马上进行TCP连接的断开，服务端会先确保断开前，所有传输到A的数据是否已经传输完毕，一旦确认传输的数据完毕，就会将回复报文的FIN字段置1，并且产生随机seq序列号。（FIN=1，ACK=x+1，seq=z，z由服务端随机生成）
4. 客户端收到服务端的TCP请求后，会回复服务端的断开请求，包含随机生成的seq字段和ACK字段，ACK字段会在服务端的TCP断开请求的seq基础上加1，从而完成服务端请求的验证回复。（FIN=1，ACK=z+1，seq=h，h为客户端随机生成）